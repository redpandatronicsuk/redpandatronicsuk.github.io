<!DOCTYPE html><html><head><meta charset="utf-8"><title>High performance low-cost servers</title><style></style><body id="preview"> <h1><a id="High_performance_lowcost_servers_0"></a>High performance low-cost servers</h1> <p>The usual trend in coputing is that hardware gets more powerful as time progresses. Many hosting comapnies, such as Amazon AWS are, however, releasing new servers which are less powerful. One reason is that you might have some services in your system which do only need very little resources, but they should be accessible all the time, so a low performance server is enough to accomplish this and the cheapest option.</p> <p>Another reason might be though that software is becoming more efficient and requires less resources to run on. For example, a few years ago, you would probably run some kind of app server and host your webpages/webservices there. These app servers used to be heavy weight and require a lot of resources just to get them up an running. More recently, people are switiching to a more micro-service driven architecture, where app servers are replaced with stripped down apps, that contain only the modules it needs and pack them into self contianed apps. These microservices can run on smaller servers. Altough the microservice architechture is very powerful when done correctly, if not done correctly, it can introduce massive overheads and is not the best solution for all systems, if you are concerned about efficiency. This goes beyond the scope of this post though, if interested however, I posted some of my previous experiences working with microservices <a href="PUT-BLOG-POST-LINK-HERE!!!!">here</a>.</p> <p>In this series of posts, we want to show how much you can get out of a <em>t2.nano</em> Amazon AWS server, using different technologies and comparing their performances. We start by writing a simple <em>Hello World</em> using different technologies. We will write a server in NGINX, NodeJS and Java. For Java we will use the popular Dropwizard framework, but also the more recent WildflySwarm.</p> <p>We will build up the complexity of the <em>Hello World</em> server, by adding more functionality and at each step we measure the performance impacts. We use JMeter to stress-test our servers. I have started an Angular 2 project, using <a href="highcharts.com">HighCharts</a> to visulaise the log files from JMeter in a browser. Test results will be displayed using this tool. I have also written a tutorial on how I wrote the visulaisation tool <a href="LATER!!!">here</a>. Our final server will be a GIS server, which we will heavily performance test. I will make the soruce code for each server implementation available on GitHub and put the links to it to the bottom of this post.</p> <p>We use <em>t2.nanos</em>, because they are the cheapest servers I am aware of, but of course any other server can be tested in the same way. In the next section, we will go through setting up a <em>t2.nano</em> server from scratch, installing the required software and setting up swap space, etc. If you already have your server set up or are comfortable with setting servers up, you can skip this section.</p> <h2><a id="Setting_up_the_server_11"></a>Setting up the server</h2> <p>Copy stuff over from previous tutotial!!!</p> <h3><a id="The_Hello_World_server_14"></a>The Hello World server</h3> <p>To keep it simple the first app we test is as simple as it gets, it just return Hello World. We keep it intentiaonally simple to ensure we are just performance testing the <em>raw</em> technologies. By this I mean that we only test the <em>core</em> of the servers. If our app would access a database or something like that, we would implictly also test the implementation of the database driver for that system.</p> <h4><a id="NGINX_17"></a>NGINX</h4> <p>If you followed the tutorial for setting up the <em>t2.nano</em> instance from scratch, you should already have NGINX installed. Optionally, you can also install <a href="oopenresty.org">OpenResty</a>, which we will install later anyways to add the Postgres database module to our NGINX server. To configure the <em>Hello World</em> server, open up <em>/etc/nginx/sites-enabled/default</em> and add the follwoing entry:</p> <pre><code><span class="hljs-title">server</span> {
 <span class="hljs-title">location</span> / {
  <span class="hljs-title">return</span> <span class="hljs-number">200</span> <span class="hljs-string">'Hello, World!'</span>;
 }
}
</code></pre> <p>And type <code>sudo service nginx reload</code> to load the new settings. Now the server should reply with <em>Hello, World!</em> to all requests. We can test this by navigating to our server in a webbrowser or by using ca command line tool such as curl. If your server is replying with a different response, look through <em>/etc/nginx/sites-enabled/default</em> to see if there are other (default) entries overwriting the server location at / and if so, remove them.</p> <h4><a id="NodeJS_28"></a>NodeJS</h4> <p>The NodeJS app is just as easy to implement. We will use the ExpressJS Generator to quick start the app and then just edit the default app to return <em>Hello, World!</em>. Assuming you already have Node and NPM installed, type <code>npm install express-generator -g</code> to install the ExpressJS generator, then go to where you want the project to be created and type <code>express rpt-server-tutorial</code>. (<em>rpt-server-tutorial</em> is the name of the app, feel free to name it something else if you prefer). This will create the scaffolding for our project. To install the depencies needed by the project, type <code>cd rpt-server-tutorial &amp;&amp; npm install</code> and to run the app <code>DEBUG=rpt-server-tutorial:* npm start</code>.</p> <p>The scaffoled app already has a user example route configured, which we wonâ€™t need, so you can either remove or just ignore it for now. Then, open up <em>routes/index.js</em> and change</p> <pre><code><span class="hljs-tag">res</span><span class="hljs-class">.render</span>(<span class="hljs-string">'index'</span>, { <span class="hljs-attribute">title</span>: <span class="hljs-string">'Express'</span> });
</code></pre> <p>to</p> <pre><code>res.<span class="hljs-built_in">send</span>(<span class="hljs-string">'Hello, World!'</span>)<span class="hljs-comment">;</span>
</code></pre> <p>You could create and edit the project on the remote server, however it is often more convient to do the development on your local machine and then transfer the project over. This can easily be done with rsync. First, <em>ssh</em> into the remote server and create the directory where you want the project to be stored under. Then, on your local machine, in the root folder of the ExpressJS project, create a file called <em><a href="http://rsync-to-server.sh">rsync-to-server.sh</a></em> with the following contents:</p> <pre><code><span class="hljs-shebang">#!/bin/bash</span>
rsync -Lrave <span class="hljs-string">"ssh -i PATH-TO-KEY.pem"</span> --exclude <span class="hljs-string">'node_modules'</span> /<span class="hljs-built_in">local</span>/path/to/project* ubuntu@SERVER-ADDR:/remote/path/to/project
</code></pre> <p>where you replace <em>PATH-TO-KEY.pem</em> with the location of where you have the pem filed strored locally you use to authenticate yourself when shhing into your server, <em>/local/path/to/project</em> with the location of the project on your local machine and <em>/remote/path/to/project</em> with the location where the project should be transfered to on the remote server. This needs to be a valid path, otherwise you will get an error.</p> <p>Once the project is on the remote server, <em>ssh</em> into it and start it up, by going to the projects root directory and typing <code>npm start</code>. You can check it simlarly to the NGINX server if it is working in a browser or with a tool such as curl. Unless you have modified the server configuration, the server will listen to requests on port 3000. Make sure that port is open in the firewall (if enabled) and in the AWS security group the server is in.</p> <h4><a id="Java_49"></a>Java</h4> <p>As we said earlier, we will make to seperate implementatins for Java. One using Dropwizard and one using a more recent tool to write server services in, namely WildflySwarm. Wildfly Swarm uses the undertow as the core server, which is non-blocking, so should outperform Dropwizard. There are other non-blocking servers for Java, such as <a href="http://vertx.io/vertx2/">Vert.X</a>, <a href="http://projects.spring.io/spring-boot/">SpringBoot</a>, <a href="http://www.ninjaframework.org/">Ninja</a>, <a href="https://ratpack.io/">RetPack</a>. <a href="https://github.com/webbit/webbit">Webbit</a>, <a href="http://twitter.github.io/finagle/">Finagle</a>. I choose WidlfySwarm here, because I liked to use the Wildfly Application Server, but ever since I switched away from application servers, in favour for services, I found myself mainly using NodeJS and NGINX. WildflySwarm is backed by RedHat and I think has great potential for the future. I initailly switched to NodeJS and especially NGINX because of performance, if however the newer non-blocking Java implementations can compare with efficaincy, I might go back to doing more projects in Java.</p> <h5><a id="Dropwizard_52"></a>Dropwizard</h5> <p>see HPLCS dropwiz</p> <h4><a id="Others_54"></a>Others</h4> <p>Of course you can also write webservices using completely different tools to the ones mentioned here. For example, fur Ruby there is <a href="http://www.sinatrarb.com">Sinatra</a>,</p> 