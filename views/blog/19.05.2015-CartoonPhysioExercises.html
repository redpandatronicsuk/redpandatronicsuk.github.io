<h1>Cartoon Physio Exercise Vids</h1> <p> I am currently working on a project with ICH and UCL, to build an app for children with JIA. One of the requirements was to put the physio exercises, the children are prescribed by their doctors, in the app, so they can log their adherence to their presricbed exercise regime. We also need to display the exercises to the children, so they know how to do the exercises correctly. </p> <figure> <img src="images/blog/exercise-cover-sheet-2014-p1.png" style="width:49%"> <img src="images/blog/exercise-cover-sheet-2014-p2.png" style="width:49%"> <figcaption>Fig1. - The paper exercise sheets given to the children by their doctors. The doctors mark on the paper which exercises have been prescribed to a particular patient.</figcaption> </figure> <p> In the pre-app era, the children were given an exercise sheet produced by their hospital, see Fig1. Originally we planned to make a digital version of the paper sheet to use within the app, but after contacting PhysioTools, the proprietor of the exercise illustrations, they did not allow us to use their illustrations wihtin their app. This came as quite a bummer at first, but in a later focus group we found out that they kids want videos in the app and not just pictures, meaning we will have to do them ourselves anyways. </p> <p> We are developing a hybrid cordova mobile app, which is supposed to look good across all devices, with all theur different resolutions, screen sizes and pixel densities. For this reason, we use SVGs rather than raster images in the app wherever possible. For the static images (in a sense of not animated), we saw great resulsts with the SVGs so far, besides redering much sharper on all devices, we also managed to reduce the file sizes and make use of the SVG DOM structure to apply CSS effects, etc. We wanted to do the same for the exercise videos, but are not aware of any software/tool that can do this for us, so this is the approach we came up with: </p> <h2>Method</h2> <figure> <img src="images/blog/video2cartoon.jpg" style="width:100%"> <figcaption> Fig2. - What we want to achieve is to turn a video into a cartoon like drawing, similar to the ones in Fig1. </figcaption> </figure> <h3>Record Videos</h3> <p> For the final version, we might hire actors to get better results, but at this stage, where we are still prototyping the app, I perfromed the exercises and had one of my team members record me. The first post-processing step is to segment out the background. Ideally we should use a greenscreen or something similar here, but because we didn't have one, we stuck white paper on the wall and floor in the area we were recording the videos. For our purposes, this is sufficient though. We do not care about the video quality too much, because we will cartoonise it anyways, so when we are editing the video, we can just adjust the exposure to make the white background (with shadows, etc. on it) a textureless white backgorund, see next section for more details. </p> <figure> <videogular vg-theme="config.theme"> <vg-media vg-src="config.sources"></vg-media> <vg-controls> <vg-play-pause-button></vg-play-pause-button> <vg-time-display>{{ currentTime | date:'mm:ss' }}</vg-time-display> <vg-scrub-bar><vg-scrub-bar-current-time></vg-scrub-bar-current-time></vg-scrub-bar> <vg-time-display>{{ timeLeft | date:'mm:ss' }}</vg-time-display> <vg-volume><vg-mute-button></vg-mute-button><vg-volume-bar></vg-volume-bar></vg-volume> <vg-fullscreen-button></vg-fullscreen-button> </vg-controls> <vg-overlay-play></vg-overlay-play> </videogular> <figcaption> Fig3. - Example of an exercise video, we repeated the exercise several times and then picked the best one. See the next section for the processing steps. </figcaption> </figure> <h3>Cartoonise in After Effects</h3> <p>Here we will birefly explain tne processing steps in Adober After Effects we used to remove the background and turn the video into a cartoon drawing. For an overview of the steps, see Fig4.</p> <figure style="width:100%"> <figure style="text-align:center; display:inline-block;width:24%; min-width: 100px"> <img style="width:100%" src="images/blog/cropped.png" alt="cropped"> <figcaption>(a)</figcaption> </figure> <figure style="text-align:center; display:inline-block;width:24%; min-width: 100px"> <img style="width:100%" src="images/blog/exposureadjusted.png" alt="exposure adjusted"> <figcaption>(b)</figcaption> </figure> <figure style="text-align:center; display:inline-block;width:24%; min-width: 100px"> <img style="width:100%" src="images/blog/rotobrush.png" alt="roto brush"> <figcaption>(c)</figcaption> </figure> <figure style="text-align:center; display:inline-block;width:24%; min-width: 100px"> <img style="width:100%" src="images/blog/cartooneffect.png" alt="cartoon"> <figcaption>(d)</figcaption> </figure> <figcaption> Fig4. - Overview of the processing steps in Adobe After Effects. For the raw video input (before cropping), see Fig3. Each step i s described in more detail in the text below. </figcaption> </figure> <h4>Crop (a)</h4> <p>As the first step, we crop the video so we only keep the region we are insterested in.</p> <h4>Exposure Adjustments (b)</h4> <p>Ideally we should have shoot the videos infront of a greenscreen and then have the background automatically subtracted. As a cheap alternative, we used white papers to plaster up the wall and floor area where we were shooting. In Fig4. (a), you can still see many shadows and reflections on the wall, that will make the forground/background segemntation step harder. To make our life easier, we adjusted the exposure of the video to strongly overexposed. In the resulting video, I look even paler than usual, but this doesn't matter as we will cartoonise the video, on the otherhand the background is merged into one white, textureless region, that will be easy to remove. We adjusted the exposure in After Effects to +2.7, which was enough to flatten out the background and leave enough detail in the foreground for the cartoonisation. Note: <em>We could also just use this video to create a cropping mask that we overlay onto the original, if we want to keep the original exposure.</em></p> <h4>Roto brush (c)</h4> <p> We applied a few roto brushes to the foreground, to let After Effects extract it. Because of the pre-processing this worked very well. </p> <h4>Cartoonise</h4> <p> As the last step, we want to cartoonise the segmented foreground region. Luckyly After Effects has the <em>Cartoon</em> effect in the <em>Stylize</em> section. We played around with the parameters until we achived our desired look, which is close to the illustrations from PhysioTools. We selected edges only, to get the illustration/sketchy look, rather than a cartoon look. The effect of the edge parameters mainky affected the line width and how much detail there is in the drawing. For example, turning the <em>Detail Radius</em> and <em>Detail Threshold</em> up reveales more details, such as the shadows on the shirt and shorts. We turned the detail level down, so we end up with few segments, which means we will use less SVG paths in the final result and save on file size. </p> <h3>Vectorise</h3> <p> Now that we have the cartoon video, we want to turn that <strong>rasterised</strong> video into a <strong>vector</strong> video. As far as we know, no such tool exists to do that automatically. So to vectorise the video we first extracted individual frames and then vectorised each frame seperately. One could use Illustrator to do that, but we decided to use VectorMagic, as it is very easy to use and usually ends up with great results. Because the image is only black and white, we set the colour pallete paraeter in VectorMagic to black and white and because we want to achive the smallest possible filesize, we picked the <em>fewer segments</em> options. </p> <p> The SVG produced by VectorMagic can be further optimised. As we have chosen a colour pallete of two, the SVG will have a layer for each colour, i.e. black and white. We do not need the white layer however, so we can remove it to reduce the filesize. After that we will only have a layer for all the black paths in our drawing. To further reduce the filesize, we can select all the paths and convert them into a compound layer. </p> <p> Lastly we can use a standard SVG optimisation tool, such as SVGO, to cut the file size further. </p> <p> Treating frames independently is not ideal, as there are many inter-frame correlations that could be exploited for compression. See, section <em>Future Improvements</em> at the bottom of this page for some thoughts on this topic. </p> <h3>SVG-Store</h3> <p> After the previous steps, we have a small, optimised SVG for each frame. The problem with that is that if we want to download the entire sequence, we need an HTTP request for each frame. We use the SVG-Store grunt plugin to merge them into a single SVG, where each original SVG file is a SVG symbol, that we can reuse later. This step is similar in it's idea to producing sprite animations, in a sense. </p> <h3>GZIP</h3> <p> Since SVGs are text files, you usually get a good compression ratio. When requesting SVG files over the internet, the server would gzip the SVG data to minimise the amount of data it needs to transfer. We however need to use the SVG files in a mobile (offline) application. To achieve the compression, we use the <a href="https://github.com/nodeca/pako">pako</a> library. We wrote a node.js script to compress the data on our development machine and then use pako again in our mobile app to extract the data. </p> <h3>Angular animation controller</h3> <p> Lastly we need some code to actually play back the animations. Remember, we store individual frames as symbols in one large SVG. Therefore, wherever in our app we can use that image as: </p> <pre style="background:#2a211c;color:#bdae9d"><span style="color:#43a8ed">&lt;<span style="font-weight:700">svg</span>></span>
  <span style="color:#43a8ed">&lt;<span style="font-weight:700">use</span> <span style="font-style:italic">xlink:href</span>=<span style="color:#049b0a">"SVG_SYMBOL_ID"</span> /></span>
<span style="color:#43a8ed">&lt;/<span style="font-weight:700">svg</span>></span>
</pre> <p> Since we have developed the mobile app in Corodova and AngularJS, we use an angular controller to control the animations. </p> <h2>Results</h2> <p> The final results of the cartoonised and vectorised exercise video: </p> <h2>Future Improvements</h2> <p> Currently, we store each frame in full, but because the transition between frames in minimal, we could just store the differences and then change the parameters for the paths that are moving. This should result in even smaller file sizes and as an added benefit would allow one to smoothly interpolate between frames. In theory, this means that we could drop most of the frames and just store keyframes thorugh which we interpolate. This is a fairly hard job though, as we need to match each path (or point on path) between frames. </p> <p> Alternatively, one could also just keep, let's say, only every 5th frame and then rather then jumping from frame-to-frame, the current frame fades out for 1/5*frameRate seconds as the next frame fades in at the same rate. NOTE: SHOW EAXMPLE TO MAKE CLEARER. </p>